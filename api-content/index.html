{"posts":[{"title":"FFT","content":"FFT 前置知识 复数 概念 离散傅里叶变换（Discrete Fourier Transform，缩写为 DFT），是傅里叶变换在时域和频域上都呈离散的形式，将信号的时域采样变换为其 DTFT 的频域采样。 FFT 是一种高效实现 DFT 的算法，称为 快速傅立叶变换（Fast Fourier Transform，FFT）。它对傅里叶变换的理论并没有新的发现，但是对于在计算机系统或者说数字系统中应用离散傅立叶变换，可以说是进了一大步。快速数论变换 (NTT) 是快速傅里叶变换（FFT）在数论基础上的实现。 在 1965 年，Cooley 和 Tukey 发表了快速傅里叶变换算法。事实上 FFT 早在这之前就被发现过了，但是在当时现代计算机并未问世，人们没有意识到 FFT 的重要性。一些调查者认为 FFT 是由 Runge 和 König 在 1924 年发现的。但事实上高斯早在 1805 年就发明了这个算法，但一直没有发表。 多项式表示 系数表示法 系数表示法就是用一个多项式的各个项系数来表达这个多项式，即使用一个系数序列来表示多项式： f(x)=a0+a1x+a2x2+⋯+anxn ⟺ f(x)={a0,a1,⋯ ,an}f(x) = a_0 + a_1 x + a_2 x ^ 2 + \\cdots +a_n x ^ n \\iff f(x) = \\{a_0, a_1, \\cdots, a_n\\} f(x)=a0​+a1​x+a2​x2+⋯+an​xn⟺f(x)={a0​,a1​,⋯,an​} 点值表示法 点值表示法是把这个多项式看成一个函数，从上面选取 n+1n + 1n+1 个点，从而利用这 n+1n + 1n+1 个点来唯一地表示这个函数。 设： f(x0)=y0=a0+a1x0+a2x02+a3x03+⋯+anx0nf(x0)=y0=a0+a1x0+a2x02+a3x03+⋯+anx0nf(x1)=y1=a1+a1x1+a2x12+a3x13+⋯+anx1nf(x2)=y2=a2+a1x2+a2x22+a3x23+⋯+anx2n⋮f(xn)=yn=an+a1xn+a2xn2+a3xn3+⋯+anxnn\\begin{array}{c}f(x_0) = y_0 = a_0 + a_1 x_0 + a_2 x_0 ^ 2 + a_3 x_0 ^ 3 + \\cdots + a_n x_0 ^ n\\\\ f(x_0) = y_0 = a_0 + a_1 x_0 + a_2 x_0 ^ 2 + a_3 x_0 ^ 3 + \\cdots + a_n x_0 ^ n\\\\ f(x_1) = y_1 = a_1 + a_1 x_1 + a_2 x_1 ^ 2 + a_3 x_1 ^ 3 + \\cdots + a_n x_1 ^ n\\\\ f(x_2) = y_2 = a_2 + a_1 x_2 + a_2 x_2 ^ 2 + a_3 x_2 ^ 3 + \\cdots + a_n x_2 ^ n\\\\ \\vdots \\\\ f(x_n) = y_n = a_n + a_1 x_n + a_2 x_n ^ 2 + a_3 x_n ^ 3 + \\cdots + a_n x_n ^ n\\\\ \\end{array} f(x0​)=y0​=a0​+a1​x0​+a2​x02​+a3​x03​+⋯+an​x0n​f(x0​)=y0​=a0​+a1​x0​+a2​x02​+a3​x03​+⋯+an​x0n​f(x1​)=y1​=a1​+a1​x1​+a2​x12​+a3​x13​+⋯+an​x1n​f(x2​)=y2​=a2​+a1​x2​+a2​x22​+a3​x23​+⋯+an​x2n​⋮f(xn​)=yn​=an​+a1​xn​+a2​xn2​+a3​xn3​+⋯+an​xnn​​ 那么用点值表示法表示 f(x)f(x)f(x) 如下 f(x)=yn=a0+a1x+a2x2+⋯+anxn ⟺ f(x)={(x0,y0),(x1,y1),⋯ ,(xn,yn)}f(x) = y_n = a_0 + a_1x + a_2 x^2 + \\cdots + a_n x ^ n \\iff f(x) = \\{(x_0, y_0), (x_1, y_1), \\cdots , (x_n, y_n)\\} f(x)=yn​=a0​+a1​x+a2​x2+⋯+an​xn⟺f(x)={(x0​,y0​),(x1​,y1​),⋯,(xn​,yn​)} 通俗地说，多项式由系数表示法转为点值表示法的过程，就是 DFT 的过程。相对地，把一个多项式的点值表示法转化为系数表示法的过程，就是 IDFT。而 FFT 就是通过取某些特殊的 xxx 的点值来加速 DFT 和 IDFT 的过程。 单位复根 考虑这样一个问题： DFT 是把多项式从系数表示转到了点值表示，那么我们把点值相乘之后，再还原成系数表示，就解决了我们的问题。上述过程如下： 假设我们 DFT 过程对于两个多项式选取的 xxx 序列相同，那么可以得到 f(x)=(x0,f(x0)),(x1,f(x1)),(x2,f(x2)),⋯ ,(xn,f(xn))g(x)=(x0,g(x0)),(x1,g(x1)),(x2,g(x2)),⋯ ,(xn,g(xn))\\begin{array}{c}f(x) = (x_0, f(x_0)), (x_1, f(x_1)), (x_2, f(x_2)), \\cdots , (x_n, f(x_n))\\\\ g(x) = (x_0, g(x_0)), (x_1, g(x_1)), (x_2, g(x_2)), \\cdots , (x_n, g(x_n))\\\\ \\end{array} f(x)=(x0​,f(x0​)),(x1​,f(x1​)),(x2​,f(x2​)),⋯,(xn​,f(xn​))g(x)=(x0​,g(x0​)),(x1​,g(x1​)),(x2​,g(x2​)),⋯,(xn​,g(xn​))​ 如果我们设 F(x)=f(x)⋅g(x)F(x) = f(x) \\cdot g(x)F(x)=f(x)⋅g(x) ，那么容易得到 F(x)F(x)F(x) 的点值表达式： F(x)={(x0,f(x0)g(x0)),(x1,f(x1)g(x1)),(x2,f(x2)g(x2)),⋯ ,(xn,f(xn)g(xn))}F(x) = \\{(x_0, f(x_0)g(x_0)), (x_1, f(x_1)g(x_1)), (x_2, f(x_2)g(x_2)), \\cdots, (x_n, f(x_n)g(x_n))\\} F(x)={(x0​,f(x0​)g(x0​)),(x1​,f(x1​)g(x1​)),(x2​,f(x2​)g(x2​)),⋯,(xn​,f(xn​)g(xn​))} 但是我们要的是系数表达式，接下来问题变成了从点值回到系数。如果我们带入到高斯消元法的方程组中去，会把复杂度变得非常高。光是计算 xi(0≤i≤n)x^i(0 \\le i \\le n)xi(0≤i≤n) 就是 nnn 项， 这就已经 O(n2)O(n^2)O(n2) 了， 跟别说还要把 n+1n + 1n+1 个方程进行消元…… 因此我们不去计算 xix^ixi .111 和 −1-1−1 的幂都很好算，但是仅仅有两个也不够，我们至少需要 n+1n + 1n+1 个。利用我们刚学的长度为 111 的虚数，这些数不管怎么乘长度都是 111 。我们需要的是 ωk=1\\omega^k = 1ωk=1 中的 ω\\omegaω ，容易想到 −i-i−i 和 iii 是符合的。除此以外： 观察上图，容易发现这是一个单位圆（圆心为原点，半径为 111 ），单位圆上的向量模长均为 111 ，根据复数的运算法则，两个复数相乘，在复平面上表示为两个向量模长相乘，辐角相加。因此两个模长为 111 的向量相乘，得到的仍是模长为 111 的向量，辐角为两个向量辐角的和。因此我们可以将 ωk=1\\omega ^ k = 1ωk=1 中的 ω\\omegaω 理解为复平面上的一个单位向量，满足它的辐角的 kkk 倍恰好是 360∘360^ \\circ360∘ ——即把圆周 kkk 等分的角。我们把符合以上条件的复数（复平面上的向量）称为复根，用 ω\\omegaω 表示。 定义 严谨地，我们称 xn=1x^n = 1xn=1 在复数意义下的解是 nnn 次复根。显然，这样的解有 nnn 个，设 ωn=e2πin\\omega_n = e^\\frac{2\\pi i}{n}ωn​=en2πi​ ，则 xn=1x^ n = 1xn=1 的解集表示为 {ωnk∣k=0,0,1,⋯ ,n−1}\\{\\omega_n ^ k \\mid k = 0, 0, 1, \\cdots, n - 1\\}{ωnk​∣k=0,0,1,⋯,n−1} 。我们称 ω\\omegaω 是 nnn 次单位复根（the nnn -th root of unity）。根据复平面的知识，nnn 次单位复根是复平面把单位圆 nnn 等分的第一个角所对应的向量。其它复根均可以用单位复根的幂表示。 另一方面，根据欧拉公式，还可以得到 ωn=e2πin=cos⁡(2πn)+i⋅sin⁡(2πn)\\omega_n = e^\\frac{2 \\pi i}{n} = \\cos(\\dfrac{2\\pi}{n}) +i \\cdot \\sin (\\dfrac{2\\pi}{n})ωn​=en2πi​=cos(n2π​)+i⋅sin(n2π​) 。 举个例子，当 n=4n = 4n=4 时， ωn=i\\omega_n = iωn​=i ，即 iii 就是 444 次单位复根： 当 n=4n = 4n=4 的时候，相当于把单位圆等分 n=4n = 4n=4 份。将每一份按照极角编号，那么我们只要知道 ω41\\omega_4^1ω41​ 因为它的角度是相当于单位角度），就能知道 ω40,ω41,ω42,ω43\\omega_4^0, \\omega_4^1, \\omega_4^2, \\omega_4^3ω40​,ω41​,ω42​,ω43​ 。 ω40\\omega _4^0ω40​ 恒等于 111 ， ω42\\omega_4^2ω42​ 的角度是 ω41\\omega_4^1ω41​ 的两倍，所以 ω42=(ω41)2=i2=−1\\omega_4^2 = (\\omega_4^1)^2 = i^2=-1ω42​=(ω41​)2=i2=−1 ，依次以此类推。 性质 单位复根有三个重要的性质。对于任意正整数 nnn 和整数 kkk : ωnn=1ωnk=ω2n2kω2nk+n=−ω2nk\\begin{array}{c} \\omega_n^n = 1\\\\ \\omega_n^k =\\omega_{2n}^{2k}\\\\ \\omega_{2n}^{k + n} = -\\omega_{2n}^k\\\\ \\end{array} ωnn​=1ωnk​=ω2n2k​ω2nk+n​=−ω2nk​​ 快速傅里叶变换 FFT 算法的基本思想是分治。就 DFT 来说，它分治地来求当 x=ωnkx = \\omega_n^kx=ωnk​ 的时候 f(x)f(x)f(x) 的值。它的分治思想体现在将多项式分为奇次项和偶次项处理。 举个例子，对于一共 888 项的多项式 f(x)=a0+a1x+a2x2+a3x3+a4x4+a5x5+a6x6a7x7f(x) = a_0 + a _ 1 x + a _ 2 x ^ 2 + a _ 3 x ^ 3 + a _ 4 x ^ 4 + a _ 5 x ^ 5 + a _ 6 x ^ 6 a _ 7 x ^ 7 f(x)=a0​+a1​x+a2​x2+a3​x3+a4​x4+a5​x5+a6​x6a7​x7 按照次数的奇偶来分成两组，然后右边提出来一个 xxx cf(x)=(a0+a2x2+a4x4+a6x6)+(a1x+a3x3+a5x5+a7x7)=(a0+a2x2+a4x4+a6x6)+x(a1+a3x2+a5x4+a7x6)\\begin{aligned}{c}f(x) &amp;= (a_0 + a_2 x ^ 2 + a_4 x ^ 4 + a_6 x ^ 6) + (a_1x + a_3 x ^ 3 + a_5 x ^ 5 + a_7 x ^ 7) \\\\ &amp;= (a_0 + a_2 x ^ 2 + a_4 x ^ 4 + a_6 x ^ 6) + x(a_1 + a_3 x ^ 2 + a_5 x ^ 4 + a_7 x ^ 6)\\\\ \\end{aligned} cf(x)​=(a0​+a2​x2+a4​x4+a6​x6)+(a1​x+a3​x3+a5​x5+a7​x7)=(a0​+a2​x2+a4​x4+a6​x6)+x(a1​+a3​x2+a5​x4+a7​x6)​ 分别用奇偶次次项数建立新的函数 G(x)=a0+a2x+a4x2+a6x3H(x)=a1+a3x+a5x2+a7x3\\begin{array}{c}G(x) = a_0 + a_2x + a_4x^2 + a_6x^3\\\\ H(x) = a_1 + a_3x + a_5x ^ 2 + a_7x_3\\\\ \\end{array} G(x)=a0​+a2​x+a4​x2+a6​x3H(x)=a1​+a3​x+a5​x2+a7​x3​​ 那么原来的 f(x)f(x)f(x) 用新函数表示为 DET⁡(f(ωnk))=DET⁡(G((ωnk)2))+ωnk×DET⁡(H((ωnk)2))=DET⁡(G(ωn2k))+ωnk×DET⁡(H(ωn2k))=DET⁡(G(ωn/2k))+ωnk×DET⁡(H(ωn/2k))\\begin{aligned}\\operatorname{DET}(f(\\omega_n^k)) &amp;=\\operatorname{DET}(G((\\omega_{n}^{k})^2)) + \\omega_{n}^{k} \\times \\operatorname{DET}(H((\\omega_n^k)^2))\\\\ &amp;= \\operatorname{DET}(G(\\omega_{n}^{2k})) + \\omega_{n}^{k} \\times \\operatorname{DET}(H(\\omega_n^{2k}))\\\\ &amp;=\\operatorname{DET}(G(\\omega_{n / 2}^{k})) + \\omega_{n}^{k} \\times \\operatorname{DET}(H(\\omega_{n / 2}^{k}))\\\\ \\end{aligned} DET(f(ωnk​))​=DET(G((ωnk​)2))+ωnk​×DET(H((ωnk​)2))=DET(G(ωn2k​))+ωnk​×DET(H(ωn2k​))=DET(G(ωn/2k​))+ωnk​×DET(H(ωn/2k​))​ 同理可得 DET⁡(f(ωnk+n/2))=DET⁡(G(ωn2k+n))+ωnk+n/2×DET⁡(H(ωn2k+n))=DET⁡(G(ωn2k))−ωnk×DET⁡(H(ωn2k))=DET⁡(G(ωn/2k))−ωnk×DET⁡(H(ωn/2k))\\begin{aligned}\\operatorname{DET}(f(\\omega_n^{k + n / 2})) &amp;=\\operatorname{DET}(G(\\omega_{n}^{2k + n})) + \\omega_{n}^{k + n / 2} \\times \\operatorname{DET}(H(\\omega_n^{2k + n}))\\\\ &amp;= \\operatorname{DET}(G(\\omega_{n}^{2k})) - \\omega_{n}^{k} \\times \\operatorname{DET}(H(\\omega_n^{2k}))\\\\ &amp;=\\operatorname{DET}(G(\\omega_{n / 2}^{k})) - \\omega_{n}^{k} \\times \\operatorname{DET}(H(\\omega_{n / 2}^{k}))\\\\ \\end{aligned} DET(f(ωnk+n/2​))​=DET(G(ωn2k+n​))+ωnk+n/2​×DET(H(ωn2k+n​))=DET(G(ωn2k​))−ωnk​×DET(H(ωn2k​))=DET(G(ωn/2k​))−ωnk​×DET(H(ωn/2k​))​ 因此我们求出了 DFT⁡(G(ωn/2k))\\operatorname{DFT}(G(\\omega_{n / 2}^{k}))DFT(G(ωn/2k​)) 和 DFT⁡(H(ωn/2k))\\operatorname{DFT}(H(\\omega_{n / 2}^{k}))DFT(H(ωn/2k​)) 后，就可以同时求出 DFT⁡(f(ωnk))\\operatorname{DFT}(f(\\omega_{n}^{k}))DFT(f(ωnk​)) 和 DFT⁡(H(ωnk+n/2))\\operatorname{DFT}(H(\\omega_{n}^{k + n / 2}))DFT(H(ωnk+n/2​)) 。于是对 GGG 和 HHH 分别递归 DFT即可。 考虑到分治 DFT 能处理的多项式长度只能是 2m(m∈N∗)2^m(m \\in N ^ \\ast)2m(m∈N∗) ，否则在分治的时候左右不一样长，右边就取不到系数了。所以要在第一次 DFT 之前就把序列向上补成长度为 2m(m∈N∗)2^m(m \\in N ^ \\ast)2m(m∈N∗) （高次系数补 000 ）、最高项次数为 2m−12^m - 12m−1 的多项式。 在代入值的时候，因为要代入 nnn 个不同值，所以我们代入 ωn0,ωn1,ωn2,⋯ ,ωnn−1(n=2m(m∈N∗))\\omega_n^0, \\omega_n^1, \\omega_n^2, \\cdots, \\omega_n^{n - 1}(n = 2^m(m \\in N^\\ast))ωn0​,ωn1​,ωn2​,⋯,ωnn−1​(n=2m(m∈N∗)) 一共 2m2^m2m​ 个不同值。 代码实现方面，STL 提供了复数的模板，当然也可以手动实现。两者区别在于，使用 STL 的 complex 可以调用 exp 函数求出 ωn\\omega_nωn​ 。但事实上使用欧拉公式得到的虚数来求 ωn\\omega_nωn​ 也是等价的。 时间复杂度 O(nlog⁡n)O(n \\log n)O(nlogn) 。 位逆序置换 这个算法还可以从“分治”的角度继续优化。我们每一次都会把整个多项式的奇数次项和偶数次项系数分开，一直分到只剩下一个系数。但是，这个递归的过程需要更多的内存。因此，我们可以先“模仿递归”把这些系数在原数组中“拆分”，然后再“倍增”地去合并这些算出来的值。 以 888 项多项式为例，模拟拆分的过程： 初始序列为 {x0,x1,x2,x3,x4,x5,x6,x7}\\{x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7\\}{x0​,x1​,x2​,x3​,x4​,x5​,x6​,x7​} 一次二分之后 {x0,x2,x4,x6},{x1,x3,x5,x7}\\{x_0, x_2, x_4, x_6\\}, \\{x_1, x_3, x_5, x_7\\}{x0​,x2​,x4​,x6​},{x1​,x3​,x5​,x7​} 两次二分之后 {x0,x4},{x2,x6},{x1,x5},{x3,x7}\\{x_0, x_4\\}, \\{x_2, x_6\\}, \\{x_1, x_5\\}, \\{x_3, x_7\\}{x0​,x4​},{x2​,x6​},{x1​,x5​},{x3​,x7​} 三次二分之后 {x0}{x4}{x2}{x6}{x1}{x5}{x3}{x7}\\{x_0\\}\\{x_4\\}\\{x_2\\}\\{x_6\\}\\{x_1\\}\\{x_5\\}\\{x_3\\}\\{x_7\\}{x0​}{x4​}{x2​}{x6​}{x1​}{x5​}{x3​}{x7​} 规律：其实就是原来的那个序列，每个数用二进制表示，然后把二进制翻转对称一下，就是最终那个位置的下标。比如 x1x_1x1​ 是 001，翻转是 100，也就是 4，而且最后那个位置确实是 4。我们称这个变换为位逆序置换（bit-reversal permutation，国内也称蝴蝶变换）。 根据它的定义，我们可以在 O(mlog⁡n)O(m \\log n)O(mlogn) 的时间内求出每个数变换后的结果： 快速傅里叶逆变换 傅里叶逆变换可以用傅里叶变换表示。对此我们有两种理解方式。 线性代数角度 IDFT（傅里叶反变换）的作用，是把目标多项式的点值形式转换成系数形式。而 DFT 本身是个线性变换，可以理解为将目标多项式当作向量，左乘一个矩阵得到变换后的向量，以模拟把单位复根代入多项式的过程： [y0y1y2y3⋮yn−1]=[1111⋯11ωn1ωn2ωn3⋯ωnn−11ωn2ωn4ωn6⋯ωn2(n−1)1ωn3ωn6ωn9⋯ωn3(n−1)⋮⋮⋮⋮⋱⋮1ωnn−1ωn2(n−1)ωn3(n−1)⋯ωn(n−1)2][a0a1a2a3⋮an−1]\\begin{bmatrix}y_0 \\\\ y_1 \\\\ y_2 \\\\ y_3 \\\\ \\vdots \\\\ y_{n-1} \\end{bmatrix} = \\begin{bmatrix}1 &amp; 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 \\\\ 1 &amp; \\omega_n^1 &amp; \\omega_n^2 &amp; \\omega_n^3 &amp; \\cdots &amp; \\omega_n^{n-1} \\\\ 1 &amp; \\omega_n^2 &amp; \\omega_n^4 &amp; \\omega_n^6 &amp; \\cdots &amp; \\omega_n^{2(n-1)} \\\\ 1 &amp; \\omega_n^3 &amp; \\omega_n^6 &amp; \\omega_n^9 &amp; \\cdots &amp; \\omega_n^{3(n-1)} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; \\omega_n^{n-1} &amp; \\omega_n^{2(n-1)} &amp; \\omega_n^{3(n-1)} &amp; \\cdots &amp; \\omega_n^{(n-1)^2} \\end{bmatrix} \\begin{bmatrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ a_3 \\\\ \\vdots \\\\ a_{n-1} \\end{bmatrix} ⎣⎢⎢⎢⎢⎢⎢⎢⎡​y0​y1​y2​y3​⋮yn−1​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎢⎢⎢⎢⎡​1111⋮1​1ωn1​ωn2​ωn3​⋮ωnn−1​​1ωn2​ωn4​ωn6​⋮ωn2(n−1)​​1ωn3​ωn6​ωn9​⋮ωn3(n−1)​​⋯⋯⋯⋯⋱⋯​1ωnn−1​ωn2(n−1)​ωn3(n−1)​⋮ωn(n−1)2​​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎢⎢⎡​a0​a1​a2​a3​⋮an−1​​⎦⎥⎥⎥⎥⎥⎥⎥⎤​ 现在我们已经得到最左边的结果了，中间的 xxx 值在目标多项式的点值表示中也是一一对应的，所以，根据矩阵的基础知识，我们只要在式子两边左乘中间那个大矩阵的逆矩阵就行了。由于这个矩阵的元素非常特殊，它的逆矩阵也有特殊的性质，就是每一项取倒数，再除以 nnn ，就能得到它的逆矩阵。 为了使计算的结果为原来的倒数，根据单位复根的性质并结合欧拉公式，可以得到 1ωk=ωk−1=e−2πik=cos⁡(2πk)+i⋅sin⁡(−2πk) \\frac{1}{\\omega_k}=\\omega_k^{-1}=e^{-\\frac{2\\pi i}{k}}=\\cos\\left(\\frac{2\\pi}{k}\\right)+i\\cdot \\sin\\left(-\\frac{2\\pi}{k}\\right) ωk​1​=ωk−1​=e−k2πi​=cos(k2π​)+i⋅sin(−k2π​) 因此我们可以尝试着把单位根 ωk\\omega_kωk​ 取成 e−2πike^{-\\frac{2 \\pi i}{k}}e−k2πi​ 这样我们的计算结果就会变成原来的倒数，而其它的操作过程与 DFT 是完全相同的。我们可以定义一个函数，在里面加一个参数 111 或者是 −1-1−1 ，然后把它乘到 π\\piπ 上。传入 111 就是 DFT，传入 −1-1−1 就是 IDFT。 单位复根周期性 利用单位复根的周期性同样可以理解 IDFT 与 DFT 之间的关系。 考虑原本的多项式是 f(x)=a0+a1x+a2x2+⋯+an−1xn−1=∑i=0n−1aixif(x)=a_0+a_1x+a_2x^2+\\cdots+a_{n-1}x^{n-1}=\\sum_{i=0}^{n-1}a_ix^if(x)=a0​+a1​x+a2​x2+⋯+an−1​xn−1=∑i=0n−1​ai​xi​ 。而 IDFT 就是把你的点值表示还原为系数表示。 考虑 构造法。我们已知 yi=f(ωni),i∈{0,1,⋯ ,n−1}y_i=f\\left( \\omega_n^i \\right),i\\in\\{0,1,\\cdots,n-1\\}yi​=f(ωni​),i∈{0,1,⋯,n−1} ，求 {a0,a1,⋯ ,an−1}\\{a_0,a_1,\\cdots,a_{n-1}\\}{a0​,a1​,⋯,an−1​} 。构造多项式如下\\ A(x)=∑i=0n−1yixi A(x)=\\sum_{i=0}^{n-1}y_ix^i A(x)=i=0∑n−1​yi​xi 相当于把 {y0,y1,y2,⋯ ,yn−1}\\{y_0,y_1,y_2,\\cdots,y_{n-1}\\}{y0​,y1​,y2​,⋯,yn−1​} 当做多项式 AAA​ 的系数表示法。 这时我们有两种推导方式，这对应了两种实现方法。 方法一 设 bi=ωn−1b_i = \\omega_n^{-1}bi​=ωn−1​ ，则多项式 AAA 在 x=b0,b1,⋯ ,bn−1x=b_0,b_1,\\cdots,b_{n-1}x=b0​,b1​,⋯,bn−1​ 处的点值表示法为 {A(b0),A(b1),⋯ ,A(bn−1)}\\left\\{ A(b_0),A(b_1),\\cdots,A(b_{n-1}) \\right\\}{A(b0​),A(b1​),⋯,A(bn−1​)} 对 A(x)A(x)A(x) 的定义式做一下变换，可以将 A(bk)A(b_k)A(bk​) 表示为 A(bk)=∑i=0n−1f(ωni)ωn−ik=∑i=0n−1ωn−ik∑j=0n−1aj(ωni)j=∑i=0n−1∑j=0n−1ajωni(j−k)=∑j=0n−1aj∑i=0n−1(ωnj−k)i \\begin{aligned} A(b_k)&amp;=\\sum_{i=0}^{n-1}f(\\omega_n^i)\\omega_n^{-ik}=\\sum_{i=0}^{n-1}\\omega_n^{-ik}\\sum_{j=0}^{n-1}a_j(\\omega_n^i)^{j}\\\\ &amp;=\\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1}a_j\\omega_n^{i(j-k)}=\\sum_{j=0}^{n-1}a_j\\sum_{i=0}^{n-1}\\left(\\omega_n^{j-k}\\right)^i\\\\ \\end{aligned} A(bk​)​=i=0∑n−1​f(ωni​)ωn−ik​=i=0∑n−1​ωn−ik​j=0∑n−1​aj​(ωni​)j=i=0∑n−1​j=0∑n−1​aj​ωni(j−k)​=j=0∑n−1​aj​i=0∑n−1​(ωnj−k​)i​ 记 S(ωna)=∑i=0n−1(ωna)iS\\left(\\omega_n^a\\right)=\\sum_{i=0}^{n-1}\\left(\\omega_n^a\\right)^iS(ωna​)=∑i=0n−1​(ωna​)i 当 a=0(mod n)a = 0 \\left(\\mod n\\right)a=0(modn) 时， S(ωna)=nS(\\omega_n^a) = nS(ωna​)=n 。 当 a≠0(mod n)a \\neq 0 (\\mod n)a​=0(modn) 时， 我们错位相减 S(ωna)=∑i=0n−1(ωna)iωnaS(ωna)=∑i=1n(ωna)iS(ωna)=(ωna)n−(ωna)0ωna−1=0 \\begin{aligned} S\\left(\\omega_n^a\\right)&amp;=\\sum_{i=0}^{n-1}\\left(\\omega_n^a\\right)^i\\\\ \\omega_n^a S\\left(\\omega_n^a\\right)&amp;=\\sum_{i=1}^{n}\\left(\\omega_n^a\\right)^i\\\\ S\\left(\\omega_n^a\\right)&amp;=\\frac{\\left(\\omega_n^a\\right)^n-\\left(\\omega_n^a\\right)^0}{\\omega_n^a-1}=0\\\\ \\end{aligned} S(ωna​)ωna​S(ωna​)S(ωna​)​=i=0∑n−1​(ωna​)i=i=1∑n​(ωna​)i=ωna​−1(ωna​)n−(ωna​)0​=0​ 也就是说 S(ωna)={n,a=00,a≠0 S\\left(\\omega_n^a\\right)= \\left\\{\\begin{aligned} n,a=0\\\\ 0,a\\neq 0 \\end{aligned}\\right. S(ωna​)={n,a=00,a​=0​ 也就是说给定点 bi=ωn−1b_i = \\omega_n^{-1}bi​=ωn−1​ ， 则 AAA 的点值表示法为 {(b0,A(b0)),(b1,A(b1)),⋯ ,(bn−1,A(bn−1))}={(b0,a0⋅n),(b1,a1⋅n),⋯ ,(bn−1,an−1⋅n)} \\begin{aligned} &amp;\\left\\{ (b_0,A(b_0)),(b_1,A(b_1)),\\cdots,(b_{n-1},A(b_{n-1})) \\right\\}\\\\ =&amp;\\left\\{ (b_0,a_0\\cdot n),(b_1,a_1\\cdot n),\\cdots,(b_{n-1},a_{n-1}\\cdot n) \\right\\} \\end{aligned} =​{(b0​,A(b0​)),(b1​,A(b1​)),⋯,(bn−1​,A(bn−1​))}{(b0​,a0​⋅n),(b1​,a1​⋅n),⋯,(bn−1​,an−1​⋅n)}​ 综上所述，我们取单位根为其倒数，对 {y0,y1,y2,⋯ ,yn−1}\\{y_0,y_1,y_2,\\cdots,y_{n-1}\\}{y0​,y1​,y2​,⋯,yn−1​} 跑一遍 FFT，然后除以 nnn 即可得到 f(x)f(x)f(x) 的系数表示。 方法二 我们直接将 ωni\\omega _n^iωni​ 代入 A(x)A(x)A(x) 。 推导的过程与方法一大同小异，最终我们得到 A(ωnk)=∑j=0n−1ajS(ωnj+k)A(\\omega_n^k) = \\sum_{j=0}^{n-1}a_jS\\left(\\omega_n^{j+k}\\right)A(ωnk​)=∑j=0n−1​aj​S(ωnj+k​) 。 当且仅当 j+k=0(modn)j+k=0 \\pmod{n}j+k=0(modn) 时有 S(ωnj+k)=nS\\left(\\omega_n^{j+k}\\right) = nS(ωnj+k​)=n ，否则为 000 。因此 A(ωnk)=an−k⋅nA(\\omega_n^k) = a_{n-k}\\cdot nA(ωnk​)=an−k​⋅n 。 这意味着我们将 {y0,y1,y2,⋯ ,yn−1}\\{y_0,y_1,y_2,\\cdots,y_{n-1}\\}{y0​,y1​,y2​,⋯,yn−1​} 做 DFT 变换后，反转再除以 nnn ，同样可以还原 f(x)f(x)f(x) 的系数表示。 代码实现 所以我们 FFT 函数可以集 DFT 和 IDFT 于一身。代码实现如下： 快速数论变换 若要计算的多项式系数是别的具有特殊意义的整数，那么 FFT 全部用浮点数运算，从时间上比整数运算慢，且只能用 long double 类型。 要应用数论变化从而避开浮点运算精度问题，参见 快速数论变换。 ","link":"https://evrgardenviolet.github.io/post/fft/"},{"title":"Dirichlet 卷积","content":"Dirichlet 卷积 定义 对于两个数论函数 f(x)f(x)f(x) 和 g(x)g(x)g(x) ， 则它们的狄利克雷卷积得到的结果 h(x)h(x)h(x) 定义为： h(x)=∑d∣xf(d)g(xd)=∑ab=xf(a)g(b)h(x) = \\sum_{d|x}f(d)g(\\frac xd) = \\sum_{ab = x} f(a)g(b) h(x)=d∣x∑​f(d)g(dx​)=ab=x∑​f(a)g(b) 上式简记为 h=f∗gh = f * g h=f∗g 狄利克雷卷积是数论函数的重要运算，数论函数的许多性质都是通过这个运算挖掘出来的。 狄利克雷卷积与狄利克雷生成函数（DGF）密切相关。对于两个序列 f,gf, gf,g ， 其狄利克雷生成函数之积，对应的是两者的狄利克雷卷积序列的狄利克雷生成函数： F~(x)G~(x)=∑i∑jfigi(ij)x=∑i1ix∑d∣ifdgid\\tilde{F}(x)\\tilde{G}(x) = \\sum_{i} \\sum_{j}\\frac{f_i g_i}{(ij)^x} = \\sum_{i} \\frac{1}{i^x}\\sum_{d|i}f_d g_\\frac id F~(x)G~(x)=i∑​j∑​(ij)xfi​gi​​=i∑​ix1​d∣i∑​fd​gdi​​ 性质 交换律： f∗g=g∗ff * g = g * ff∗g=g∗f 。 结合律： (f∗g)∗h=f∗(g∗h)(f * g) * h = f * (g * h)(f∗g)∗h=f∗(g∗h) 。 分配率： (f+g)∗h=f∗h+g∗h(f + g) * h = f * h + g * h(f+g)∗h=f∗h+g∗h。 等式的性质： f=gf = gf=g 的充要条件是 f∗g=g∗ff * g = g * ff∗g=g∗f ， 其中数论函数 h(x)h(x)h(x) 要满足 h(x)≠0h(x) \\ne 0h(x)​=0 。 单位元： 单位函数 ε\\varepsilonε 是 Dirichlet 卷积运算中的单位元，即对于任何数论函数 fff ， 都有 f∗ε=ff * \\varepsilon = ff∗ε=f 。 逆元： 对于任何一个满足 f(x)≠0f(x) \\ne 0f(x)​=0 的数论函数，如果有另一个数论函数 g(x)g(x)g(x) 满足 f∗g=εf * g = \\varepsilonf∗g=ε ， 则称 g(x)g(x)g(x) 是 f(x)f(x)f(x) 的逆元。由 等式的性质 可知，逆元是唯一的。（PS.狄利克雷卷积运算中的逆元，在狄利克雷生成函数中相当于倒数运算。） 容易构造出 g(x)g(x)g(x) 的表达式为： g(x)=ε(x)−∑d∣x,d≠1f(d)g(xd)f(1)g(x) = \\dfrac{\\varepsilon(x) - \\sum_{d\\mid x, d\\ne 1}{f(d)g\\left(\\dfrac{x}{d}\\right)}}{f(1)} g(x)=f(1)ε(x)−∑d∣x,d​=1​f(d)g(dx​)​ 重要结论 两个积性函数的 Dirichlet 卷积也是积性函数 证明： 设两个积性函数为 f(x)f(x)f(x) 和 g(x)g(x)g(x) ， 再记 h=f∗gh = f * gh=f∗g 。 设 gcd⁡(a,b)=1\\gcd(a, b) = 1gcd(a,b)=1 ，则： h(a)=∑d1∣af(d1)g(ad1),h(b)=∑d2∣bf(d2)g(bd2),h(a) = \\sum_{d_1\\mid a} f(d_1)g(\\dfrac{a}{d_1}), h(b) = \\sum_{d_2 \\mid b}f(d_2)g(\\frac{b}{d_2}), h(a)=d1​∣a∑​f(d1​)g(d1​a​),h(b)=d2​∣b∑​f(d2​)g(d2​b​), 所以： h(a)h(b)=∑d1∣af(d1)g(ad1)∑d2∣bf(d2)g(bd2)=∑d∣abf(d)g(abd)=h(ab)\\begin {aligned}h(a)h(b)&amp;= \\sum_{d_1\\mid a}{f\\left(d_1\\right)g\\left( \\frac{a}{d_1}\\right)}\\sum_{d_2\\mid b}{f(d_2)g\\left(\\dfrac b{d_2}\\right)}\\\\ &amp;= \\sum_{d\\mid ab}{f(d)g\\left(\\dfrac{ab}d \\right)}\\\\&amp;= h(ab) \\end{aligned} h(a)h(b)​=d1​∣a∑​f(d1​)g(d1​a​)d2​∣b∑​f(d2​)g(d2​b​)=d∣ab∑​f(d)g(dab​)=h(ab)​ 综合以上两点，结论成立。 证毕 积性函数的逆元也是积性函数 证明略（滑稽） ","link":"https://evrgardenviolet.github.io/post/dirichlet-juan-ji/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... <!-- more --> Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://evrgardenviolet.github.io/post/hello-gridea/"}]}